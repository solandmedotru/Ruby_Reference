# Базовая работа с хешем
# Hash

hash = {5 => 3, 1 => 6, 3 => 2}
hash[5] #=> 3
hash[2] #=> nil
hash[3] #=> 2

#Первый случай применимости хеша: если в массиве намечаются обширные
#незаполненные (то есть заполненные nil) области, то целесообразнее использовать
#хеш с целочисленным индексом.
#Посчитать сколько совпадений каждой цифры ( inject )
array = [1, 2, 1, 2, 3, 2, 1, 2, 4, 5]
array.inject(Hash.new { 0 }) { |result, i|
  result[i] += 1
  result
} #=> {5=>1, 1=>3, 2=>4, 3=>1, 4=>1}

#Второй случай применимости хеша: если требуется подсчитать число элементов
#массива, то целессобразнее применять хеш. Кстати, вместо подсчета количества,
#можно использовать конкатенацию массивов или строк. Но это уже более сложные
#задачи, которые будут рассмотрены позже.
hash = {"comp1.mydomen.ru" => "192.168.0.3",
        "comp2.mydomen.ru" => "192.168.0.1",
        "comp3.mydomen.ru" => "192.168.0.2"}
hash["comp1.mydomen.ru"] #=> "192.168.0.3"

#Третий случай применимости хеша: когда требуется сопоставить один набор
#данных с другим, то целесообразнее использовать хеш.
array = [1, 2, 1, 2, 3, 2, 1, 2, 4, 5]
array.inject({}) { |result, i| result.update({i => 1}) { |key, old, new| old+new } } #=> {5=>1, 1=>3, 2=>4, 3=>1, 4=>1}

# Что используется в качестве ключей? (rehash)
array1 = ["а", "б"]
array2 = ["в", "г"]
hash = {array1 => 100, array2 => 300}
hash[array1] #=> 100
array1[0] = "я"
hash[array1] #=> nil
hash.rehash #=> {["я", "б"]=>100, ["в", "г"]=>300}
hash[array1] #=> 100

# Хеширование (hash)
[1, 2, 3].hash #=> 25

# Создание HASH
# Из одномерного массива
array = [1, 4, 5, 3, 2, 2]
Hash[*array] #=> {5=>3, 1=>4, 2=>2}

# Из двумерного массива
array = [[1, 4], [5, 3], [2, 2]]
Hash[*array.flatten] #=> {5=>3, 1=>4, 2=>2}
array = [[1, 5, 2], [4, 3, 2]]
Hash[*array.transpose.flatten] #=> {5=>3, 1=>4, 2=>2}

# Если нет данных
hash = {}
hash[1] = 4
hash[5] = 3
hash[2] = 2
hash #=> {5=>3, 1=>4, 2=>2}

# Известен только тип значений
hash = Hash.new("")
hash["песенка про зайцев"] += "В тёмно-синем лесу, "
hash["песенка про зайцев"] += "где трепещут осины"
hash #=> {"песенка про зайцев"=>"В темносинем лесу, где трепещут осины"}

hash = Hash.new(0)
hash["зарплата"] += 60
hash["зарплата"] *= 21
hash #=> {"зарплата"=>1260}
# Всё известно и дано
{"март" => 400, "январь" => 350, "февраль" => 200}

# ***************************************

# Заметка четвертая(работа с хешем, итераторы)

# Получение массива значений и массива ключей ( keys и values )
{1=>4, 5=>3, 2=>2}.keys   #=> [1, 2, 5]
{1=>4, 5=>3, 2=>2}.values #=> [4, 3, 2]

# Замена ключей на значения ( invert )
hash = {"первый ключ"=>4, "второй ключ"=>5}
hash.invert                                 #=> {4=>"первый ключ", 5=>"второй ключ"}

hash = {"первый ключ"=>10, "второй ключ"=>10}
hash.invert                                      #=> {10=>"второй ключ"}
#Небольшая хитрость:   hash.invert.invert  возвратит  нам  хеш  с  уникальными значениями.

# Обновление пары ( inject )
array = [1, 2, 1, 2, 3, 2, 1, 2, 4, 5]
array.inject({}){ |result, i| result.update({i=>1}){ |key, old, new| old + new } }   #=> {5=>1, 1=>3, 2=>4, 3=>1, 4=>1}

# Слияние двух массивов ( merge! или merge )
hash1 = {3 => "a", 4 => "c"}
hash2 = {5 => "r", 7 => "t"}
hash1.merge!(hash2)          #=> {5=>"r", 7=>"t", 3=>"a", 4=>"c"}
#Если во втором массиве ключ будет совпадать с каким-либо ключем из первого массива, значение будет заменено на значение из второго массива.

# Размер ассоциативного массива ( size )
hash = {5=>1, 1=>3, 2=>4, 3=>1, 4=>1}
hash.size                             #=> 5

# Удаление пары по ключу ( delete )
hash = {5=>1, 1=>3, 2=>4, 3=>1, 4=>1}
hash.delete(5)                        #=> 1
hash                                  #=> {1=>3, 2=>4, 3=>1, 4=>1}
hash.delete(5)                        #=> nil

# Удаление произвольной пары ( shift )
hash = {5=>3, 1=>6, 3=>2}
hash.shift                #=> [5, 3]
hash                      #=> {1=>6, 3=>2}

# Преобразовать в индексный массив ( to_a )
hash = {"гаечный ключ"=>10, "разводной ключ"=>22}
hash.to_a    #=> [["гаечный ключ", 10], ["разводной ключ", 22]]

# Упорядочение хеша ( sort и sort_by )
hash = {"гаечный ключ"=>4, "разводной ключ"=>10}
hash.sort    #=> [["гаечный ключ", 4], ["разводной ключ", 10]]

hash = {"гаечный ключ"=>4, "разводной ключ"=>10}
hash.sort_by{ |key, value| value } #=> [["гаечный ключ", 4], ["разводной ключ", 10]]

# Поиск максимальной/ минимальной пары ( max, max_by, min, min_by )
hash = {"гаечный ключ"=>10, "разводной ключ"=>22}
hash.max    #=> ["разводной ключ", 22]
hash.min    #=> ["гаечный ключ" , 10]

hash = {"гаечный ключ"=>10, "разводной ключ"=>22}
hash.max_by{ |key, value| value }                 #=> ["разводной ключ", 22]
hash.min_by{ |array| array[0] }                   #=> ["гаечный ключ" , 10]

# Хеш пустой? ( empty? )
empty_hash = {}
filled_hash = {"гаечный"=>20, "замочный"=>"английский", "разводной"=>34}
empty_hash .empty?    #=> true
filled_hash.empty?    #=> false

# Есть такой ключ? ( key? )
pocket = {"гаечный"=>20, "замочный"=>"английский", "разводной"=>34}
pocket.key?("гаечный")    #=> true

# Есть такое значение? ( value? )
pocket = {"гаечный"=>20, "замочный"=>"английский", "разводной"=>34}
pocket.value?("английский")    #=> true

# Работа с итераторами ( map, find_all, inject )
hash = {"гаечный ключ"=>4, "разводной ключ"=>10}
hash.find_all{ |array| array[1] < 5 }    #=> [["гаечный ключ", 4]]
hash.map { |array| "#{array[0]} на #{array[1]}" }    #=> ["гаечный ключ на 4", "разводной ключ на 10"]
hash.inject(0){ |result, array| result + array[1] }    #=> 14

hash = {"гаечный ключ"=>4, "разводной ключ"=>10}
hash.find_all{ |key, value| value < 5 }    #=> [["гаечный ключ", 4]]
hash.map{ |key, value| "#{key} на #{value}" }    #=> ["гаечный ключ на 4", "разводной ключ на 10"]
hash.inject(0){ |result, (key, value)| result + value }    #=> 14

hash = {"гаечный ключ"=>4, "разводной ключ"=>10}
hash.map { | key, value | "#{key} на #{value}" } #=> ["гаечный ключ на 4", "разводной ключ на 10"]
hash.map                                         #=> [["гаечный ключ", 4], ["разводной ключ", 10]]